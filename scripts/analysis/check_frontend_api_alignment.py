"""
Quick static audit for frontend/API field alignment.

Focuses on organizing scorecard paths and known cross-file hazards:
- score_breakdown key mismatches
- duplicate top-level let/const declarations
- risky innerHTML writes without obvious escaping
"""
from __future__ import annotations

import re
from pathlib import Path


ROOT = Path(__file__).resolve().parents[2]
JS_DIR = ROOT / "files" / "js"
API_ORGANIZING = ROOT / "api" / "routers" / "organizing.py"
REPORT = ROOT / "docs" / "PARALLEL_FRONTEND_API_AUDIT.md"


def extract_api_breakdown_keys() -> set[str]:
    text = API_ORGANIZING.read_text(encoding="utf-8")
    keys = set(
        re.findall(
            r"'score_breakdown':\s*{([^}]*)}",
            text,
            flags=re.DOTALL,
        )
    )
    if not keys:
        return set()
    block = next(iter(keys))
    return set(re.findall(r"'([a-z_]+)'\s*:", block))


def extract_js_breakdown_keys() -> set[str]:
    scorecard = (JS_DIR / "scorecard.js").read_text(encoding="utf-8")
    return set(re.findall(r"breakdown\.([a-z_]+)", scorecard))


def find_duplicate_toplevel_decls() -> dict[str, list[str]]:
    decls: dict[str, list[str]] = {}
    for path in sorted(JS_DIR.glob("*.js")):
        lines = path.read_text(encoding="utf-8").splitlines()
        for idx, line in enumerate(lines, start=1):
            if line.startswith("let ") or line.startswith("const "):
                m = re.match(r"^(?:let|const)\s+([A-Za-z_][A-Za-z0-9_]*)", line)
                if not m:
                    continue
                name = m.group(1)
                decls.setdefault(name, []).append(f"{path.name}:{idx}")
    return {k: v for k, v in decls.items() if len(v) > 1}


def find_risky_innerhtml() -> list[str]:
    findings = []
    for path in sorted(JS_DIR.glob("*.js")):
        lines = path.read_text(encoding="utf-8").splitlines()
        for idx, line in enumerate(lines, start=1):
            if ".innerHTML" in line and "escapeHtml(" not in line:
                findings.append(f"{path.name}:{idx}")
    return findings


def main() -> int:
    api_keys = extract_api_breakdown_keys()
    js_keys = extract_js_breakdown_keys()

    missing_in_js = sorted(api_keys - js_keys)
    js_only = sorted(js_keys - api_keys)
    dupes = find_duplicate_toplevel_decls()
    risky_innerhtml = find_risky_innerhtml()

    report_lines = [
        "# Parallel Frontend/API Audit",
        "",
        "Generated by `scripts/analysis/check_frontend_api_alignment.py`.",
        "",
        "## Score Breakdown Key Diff (OSHA scorecard)",
        f"- API keys: {sorted(api_keys)}",
        f"- JS keys: {sorted(js_keys)}",
        f"- Missing in JS: {missing_in_js if missing_in_js else 'None'}",
        f"- JS-only keys: {js_only if js_only else 'None'}",
        "",
        "## Duplicate Top-Level Declarations",
    ]

    if dupes:
        for name, refs in sorted(dupes.items()):
            report_lines.append(f"- `{name}` -> {', '.join(refs)}")
    else:
        report_lines.append("- None detected")

    report_lines += ["", "## Potentially Risky innerHTML Writes"]
    if risky_innerhtml:
        report_lines.append(
            f"- Count: {len(risky_innerhtml)} (manual triage required; static check is conservative)"
        )
        report_lines.extend([f"- `{ref}`" for ref in risky_innerhtml[:40]])
        if len(risky_innerhtml) > 40:
            report_lines.append(f"- ... plus {len(risky_innerhtml) - 40} more")
    else:
        report_lines.append("- None detected")

    REPORT.write_text("\n".join(report_lines) + "\n", encoding="utf-8")
    print(f"Wrote: {REPORT}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

