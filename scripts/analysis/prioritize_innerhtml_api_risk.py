"""
Prioritize potential XSS paths in JS where API JSON data flows into innerHTML.

Heuristic:
- Find variables assigned from `await <resp>.json()`
- Find `.innerHTML =` template literal blocks
- Flag blocks that interpolate those API vars without `escapeHtml(...)`
"""
from __future__ import annotations

import re
from dataclasses import dataclass
from pathlib import Path


ROOT = Path(__file__).resolve().parents[2]
JS_DIR = ROOT / "files" / "js"
REPORT = ROOT / "docs" / "PARALLEL_INNERHTML_API_RISK_PRIORITY.md"


API_JSON_ASSIGN_RE = re.compile(
    r"\b(?:const|let|var)\s+([A-Za-z_][A-Za-z0-9_]*)\s*=\s*await\s+[A-Za-z_][A-Za-z0-9_]*\.json\(\)"
)
INTERP_RE = re.compile(r"\$\{([^}]+)\}")


@dataclass
class Risk:
    path: str
    line: int
    api_vars: list[str]
    raw_interps: list[str]
    snippet: str


def extract_api_vars(text: str) -> set[str]:
    return set(API_JSON_ASSIGN_RE.findall(text))


def iter_innerhtml_template_blocks(lines: list[str]):
    i = 0
    n = len(lines)
    while i < n:
        line = lines[i]
        if ".innerHTML" in line and "=" in line and "`" in line:
            start = i
            block = [line]
            backtick_count = line.count("`")
            i += 1
            while i < n and backtick_count % 2 != 0:
                block.append(lines[i])
                backtick_count += lines[i].count("`")
                i += 1
            yield start + 1, "\n".join(block)
        else:
            i += 1


def block_has_unescaped_api_interp(block: str, api_vars: set[str]) -> tuple[list[str], list[str]]:
    raw_api_hits = []
    api_var_hits = []
    for expr in INTERP_RE.findall(block):
        cleaned = expr.strip()
        if "escapeHtml(" in cleaned:
            continue
        for var in api_vars:
            if re.search(rf"\b{re.escape(var)}\b", cleaned):
                raw_api_hits.append(cleaned)
                api_var_hits.append(var)
                break
    return sorted(set(api_var_hits)), raw_api_hits


def main() -> int:
    risks: list[Risk] = []

    for path in sorted(JS_DIR.glob("*.js")):
        text = path.read_text(encoding="utf-8")
        lines = text.splitlines()
        api_vars = extract_api_vars(text)
        if not api_vars:
            continue

        for line_no, block in iter_innerhtml_template_blocks(lines):
            vars_hit, interps = block_has_unescaped_api_interp(block, api_vars)
            if not vars_hit:
                continue
            snippet = block.splitlines()[0].strip()
            risks.append(
                Risk(
                    path=path.name,
                    line=line_no,
                    api_vars=vars_hit,
                    raw_interps=interps[:5],
                    snippet=snippet[:180],
                )
            )

    risks.sort(key=lambda r: (r.path, r.line))

    out = [
        "# Parallel innerHTML API Risk Priority",
        "",
        "Generated by `scripts/analysis/prioritize_innerhtml_api_risk.py`.",
        "",
        "Scope: `innerHTML` template blocks that interpolate variables assigned from `await response.json()` without `escapeHtml(...)`.",
        "",
        f"- Findings: {len(risks)}",
        "",
        "## Prioritized Findings",
    ]

    if not risks:
        out.append("- None")
    else:
        for r in risks:
            out.append(
                f"- `{r.path}:{r.line}` api_vars={r.api_vars} interps={r.raw_interps} snippet=`{r.snippet}`"
            )

    REPORT.write_text("\n".join(out) + "\n", encoding="utf-8")
    print(f"Wrote: {REPORT}")
    print(f"Findings: {len(risks)}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

